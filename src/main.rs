use std::cell::RefCell;
use std::io::{Error as IoError, Read, Seek, SeekFrom};
use std::ptr::null_mut;

use anyhow::Error as AnyhowError;
use ext4::{Checksums, Options, SuperBlock};
use positioned_io::ReadAt;
use structopt::StructOpt;
use thiserror::Error;
use winapi::{
    ctypes::c_void,
    shared::ntdef::LARGE_INTEGER,
    um::{
        fileapi::{CreateFileW, SetFilePointerEx, WriteFile, OPEN_EXISTING},
        handleapi::{CloseHandle, INVALID_HANDLE_VALUE},
        winbase::{FILE_BEGIN, FILE_FLAG_NO_BUFFERING},
        winnt::{FILE_SHARE_READ, FILE_SHARE_WRITE, GENERIC_READ, GENERIC_WRITE, HANDLE},
    },
};
use windows_drives::{
    drive::BufferedHarddiskVolume,
    win32::{last_error, win32_string},
};

fn main() -> Result<(), Error> {
    let args = Args::from_args();

    /* open the volume for reading */
    let volume = BufferedHarddiskVolume::open(VOLUME_NUM).map_err(Error::OpenVolume)?;
    let volume = VolumeReader::new(volume);

    /* open ext4 filesystem */
    let mut options = Options::default();
    options.checksums = Checksums::Enabled;
    let superblock = SuperBlock::new_with_options(&volume, &options)?;

    /* read grub.cfg */
    let dir_entry = superblock.resolve_path("/grub/grub.cfg")?;
    let inode = superblock.load_inode(dir_entry.inode)?;
    let mut grubcfg = String::new();
    superblock.open(&inode)?.read_to_string(&mut grubcfg)?;

    /* parse grub.cfg */
    let pos = dbg!(grubcfg.find("menuentry 'Ubuntu")).ok_or(Error::ParseConfig)?;
    let grubcfg = &grubcfg[pos..];
    let pos = dbg!(grubcfg.find("\n")).ok_or(Error::ParseConfig)?;
    let boot_id = dbg!(&grubcfg[..pos])
        .split(' ')
        .filter(|s| s.starts_with("'") && s.ends_with("'"))
        .last()
        .ok_or(Error::ParseConfig)?
        .strip_prefix("'")
        .ok_or(Error::ParseConfig)?
        .strip_suffix("'")
        .ok_or(Error::ParseConfig)?;
    println!("Found boot id in grub.cfg: {}", boot_id);

    /* read grubenv */
    let dir_entry = superblock.resolve_path("/grub/grubenv")?;
    let inode = superblock.load_inode(dir_entry.inode)?;
    let mut grubenv = String::new();
    volume.log_blocks(true);
    superblock.open(&inode)?.read_to_string(&mut grubenv)?;
    volume.log_blocks(false);

    /* verify the read data */
    let mut offset = None;
    let mut block_size = 0;
    let mut expected_offset = None;

    let inner = volume.0.borrow();
    for (pos, sz) in &inner.blocks {
        if offset.is_none() {
            offset = Some(*pos);
        }

        if matches!(expected_offset, Some(expected_offset) if expected_offset != *pos as usize) {
            return Err(Error::InvalidEnvironmentBlock);
        }

        expected_offset = Some(*pos as usize + sz);

        block_size += sz;
    }

    let offset = offset.ok_or(Error::InvalidEnvironmentBlock)?;

    println!("\n\nOld grubenv:\n{}", grubenv);

    /* open volume for writing */
    let mut data = format!("# GRUB Environment Block\n# WARNING: Do not edit this file by tools other than grub-editenv!!!\nsaved_entry={}\n", boot_id);
    data.extend((0..block_size).map(|_| '#'));
    data.truncate(block_size);

    println!("\n\nNew grubenv:\n{}", data);

    let mut volume = VolumeWriter::new(VOLUME_NUM)?;
    let data = data.as_bytes();

    assert_eq!(1024, data.len());

    volume.write(offset, &data[..])?;

    /* going down for reboot */
    if !args.no_reboot {
        if args.shutdown {
            system_shutdown::shutdown()?;
        } else {
            system_shutdown::reboot()?;
        }
    }

    Ok(())
}

/* Args */

#[derive(StructOpt)]
struct Args {
    #[structopt(short = "s", long = "shutdown")]
    shutdown: bool,

    #[structopt(short = "n", long = "no-reboot")]
    no_reboot: bool,
}

/* VolumeReader */

struct VolumeReader<R>(RefCell<Inner<R>>);

struct Inner<R> {
    io: R,
    blocks: Vec<(u64, usize)>,
    log_blocks: bool,
}

impl<R> VolumeReader<R> {
    fn new(io: R) -> Self {
        Self(RefCell::new(Inner {
            io,
            blocks: Vec::new(),
            log_blocks: false,
        }))
    }

    fn log_blocks(&self, value: bool) {
        self.0.borrow_mut().log_blocks = value;
    }
}

impl<R: Read + Seek> ReadAt for VolumeReader<R> {
    fn read_at(&self, pos: u64, buf: &mut [u8]) -> Result<usize, IoError> {
        let mut inner = self.0.borrow_mut();

        inner.io.seek(SeekFrom::Start(pos))?;

        let sz = inner.io.read(buf)?;

        if inner.log_blocks {
            inner.blocks.push((pos, sz));
        }

        Ok(sz)
    }
}

/* VolumeWriter */

struct VolumeWriter {
    handle: HANDLE,
}

impl VolumeWriter {
    fn new(volume_num: u8) -> Result<Self, Error> {
        let path = format!("\\\\?\\HarddiskVolume{}", volume_num);
        let path = win32_string(&path);

        let handle = unsafe {
            CreateFileW(
                path.as_ptr(),
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                null_mut(),
                OPEN_EXISTING,
                FILE_FLAG_NO_BUFFERING,
                null_mut(),
            )
        };

        if handle == INVALID_HANDLE_VALUE {
            let err = last_error();
            Err(match err {
                2 => Error::DeviceNotFound,
                5 => Error::AccessDenied,
                err => Error::WinApi(err),
            })
        } else {
            Ok(Self { handle })
        }
    }

    fn write(&mut self, pos: u64, bytes: &[u8]) -> Result<(), Error> {
        let mut dist = LARGE_INTEGER::default();
        let mut new_pos = LARGE_INTEGER::default();

        let res = unsafe {
            *dist.QuadPart_mut() = pos as i64;

            SetFilePointerEx(self.handle, dist, &mut new_pos, FILE_BEGIN)
        };

        if res == 0 {
            return Err(Error::WinApiSeek(pos, last_error()));
        }

        let mut bytes_written = 0u32;
        let res = unsafe {
            WriteFile(
                self.handle,
                bytes.as_ptr() as *mut c_void,
                bytes.len() as u32,
                &mut bytes_written,
                null_mut(),
            )
        };
        if res == 0 {
            Err(Error::WinApiWrite(last_error()))
        } else if bytes_written as usize != bytes.len() {
            Err(Error::NotAllBytesWritten)
        } else {
            Ok(())
        }
    }
}

impl Drop for VolumeWriter {
    fn drop(&mut self) {
        if self.handle != INVALID_HANDLE_VALUE {
            unsafe { CloseHandle(self.handle) };
            self.handle = INVALID_HANDLE_VALUE;
        }
    }
}

#[derive(Error, Debug)]
enum Error {
    #[error("IO Error: {0}")]
    IoError(#[from] IoError),

    #[error("Unable to open volume: {0}")]
    OpenVolume(String),

    #[error("Ext4 Error: {0}")]
    AnyhowError(#[from] AnyhowError),

    #[error("Win api error: {0:#08x}")]
    WinApi(u32),

    #[error("Error while writing data: {0:#08x}")]
    WinApiWrite(u32),

    #[error("Error while seeking to offset ({0:#08x}): {0:#08x}")]
    WinApiSeek(u64, u32),

    #[error("Not all bytes were written!")]
    NotAllBytesWritten,

    #[error("Invalid GRUB environment block!")]
    InvalidEnvironmentBlock,

    #[error("Device not found!")]
    DeviceNotFound,

    #[error("Access denied!")]
    AccessDenied,

    #[error("Unable to parse grub.cfg!")]
    ParseConfig,
}

// Tool to extract the corrent volume number:
// SIV - System Information Viewer
// http://rh-software.com/
const VOLUME_NUM: u8 = 5;
